\chapter{Massive IoT system overview}

It has a high cost to test massiveness scenarios with a massive amount of hardware devices and will require a system to control them individually, especially if the desire is to test the impact of massiveness on the individual devices. A more optimal solution is instead of buying a massive amount of devices, to emulate them through software.


For the emulation of the eNB the Amarisoft LTE 100 code will be used as it can handle 1000 \gls{UE}s \citep{Amarisoft_solutions} and is tested to synchronize with the software based NB-IoT devices that will be used. As it is a commercial BSE, it is not open source and therefore harder to add new features and change all parameters, but as the focus is the devices, the software will still be used. A longer list of parameters for the Amarisoft LTE 100 code can be found in \appref{app:Amarisoft}.

For the \gls{MDE} the code from SRS which have been tested to work with the software eNB from Amarisoft is chosen. This is chosen primarily because access to the source code is available through Keysight Technologies.\todo{check if this is okay or keysight does not want to get mentioned in this connection} As the code is designed for a single device some change have to be implemented, which requires knowledge of the original code. 

The code will produce the infrastructure of the \gls{MDE} combining and transmitting the signals produced to the \gls{eNB}. The eNB will be emulated on secondary PC, as this frees up the PC running the \gls{MDE}. The NB-IoT spectrum overlaps with the LTE or GSM spectrum, meaning the spectrum is licensed, therefore a wire is used to connect \gls{MDE} and eNB. As the path loss in the wire is quite low, compared to transmission through the air, a 30 dB attenuator is added in between to increase the dynamic spectrum of the \gls{MDE} and eNB. To convert from digital signals to RF signals, a USRP B210 is connected to each the two emulators as these \gls{SDR}s are comparable with both softwares. The setup of the emulators can be seen on \ref{fig:MassSetup}.

\begin{figure}[H]
\centering
\resizebox{0.9\textwidth}{!}{
\input{figures/Mass_setup.tex}}
\caption{Overview of the emulator setup}
\label{fig:MassSetup}
\end{figure}



%The emulation of the massiveness scenarios uses the Massive IoT and eNB (Amarisoft) components. It is possible to connect and external NB-IoT device be combining its signal with the signals from the other two components. But as the focus for this part of the emulator is to stress test the protocol this feature will not be used. The Orchestrator is not used either in this part, as it has not been prioritized to set the two system together and have the same control unit. Both components is started up from a config file. While the Amarisoft software already fits to the purpose as an eNB, the SRS software code need to be change to emulate multiple UE. To understand this changes, there will be looked into the original code

%\section{eNB emulator}
%For the emulation of the eNB the Amarisoft LTE 100 code will be used as it can handle 1000 \gls{UE} \todo{Insert ref to Amarisoft side} and is tested to synchronize with the software based NB-IoT devices that will be used. As it is a commercial BSE, it is not open source and therefore harder to add new features and change all parameters, but as the focus is the devices, the software will still be used. A longer list of parameters for the Amarisoft LTE 100 code can be found \todo{Insert appendix for this}

%\section{Massive device emulator}
%For the emulation of the massive amount of NB-IoT devices the code provide by SRS which have been tested to work with the software eNB from Amarisoft. As the code is design for a single device some change have to be implemented, which requires knowledge of the original code.



\section{Original SRS code}
The code provide by SRS is still in development and is based on the code SRS developed to LTE, which was used in \citep{thesis_report}. The structure of the code is very similar and with that, some of the structure change and solutions can be copied over from the mentioned project.

Unfortunately as the code is still in development, the msg3 transmission does not work, as it seems that it gets transmitted in a wrong time slot. \todo{Check up on if this is what we want to say} This block the possibility to get a complete attach request, so the project will only work up to the reception of msg2. The plans for the changes and solution for the parts including the full attach procedure and data transmission, can be found in \todo{ref to future works}

\textbf{Structure}\\
The code is written in C++, with a little C in some of the lower level files. The code is divided up into two sections srsLTE, which contains all the lower layer functions and the radio layer, and srsUE, which emulate a device with all the different communication layers that handles the protocol. The code contains an amount of classes for the different layers, as seen in \ref{fig:MassClass}, with the PHY and MAC layer being split up into even more classes. The structure of the PHY layer can be seen in \ref{fig:PhyClass}.

\begin{figure}[H]
\centering
\resizebox{0.5\textwidth}{!}{
\input{figures/MassClass.tex}}
\caption{Class overview of SRS emulation code}
\label{fig:MassClass}
\end{figure}

\begin{figure}[H]
\centering
\resizebox{0.5\textwidth}{!}{
\input{figures/PhyClass.tex}}
\caption{Class overview of the PHY layer from the SRS emulation code}
\label{fig:PhyClass}
\end{figure}

Here following a description of the different classes and their functionality:
\begin{itemize}
\item [Radio] The radio controls and sets all the parameters for the transmission and receiving. It is the only class connected to the SDR API and sends the data to it for transmission and receives data from it too. 
\item [PHY] The PHY layer handles the syncronatation, the receiving and decoding of MIB and SIBs messages and decoding and encoding of transmission and received data. As it have a high number of task, it is split up into an amount of underclasses.
	\begin{itemize}
	\item [PHCH recv] 
	\item [PHCH common]
	\item [Thread pool]
	\item [PHCH workers]
	\item [NPRACH]
	\end{itemize}
\item [MAC]
\item [RLC]
\item [PDCP]
\item [RRC]
\item [GW]
\item [NAS]
\item [USIM]
\end{itemize}

As multiple tasks is needed to be handled at the same time in the different layers, threading is used in multiple classes \todo{list the classes with threads} Between these classes are there some interfaces, that handles the movement of data and grants. \todo{description of the necessity of this}

\textbf{Flow of the code}\\
\todo{the flow is not build up into anything, it might be split or parallelised or follow a sequence}
The flow of the code is build up into multiple section, which is shown in \todo{ref to figure}. After the initialization the steps is matching the steps needed for a device to connect to an eNB. The different threads will go to different state, depending on which step in the produce\todo{?? process ??} the code have made it to.

\todo{Flowchart over the process}

\todo{Short description on the different steps}

To have the code emulate multiple devices, some parts of the original device is needed to be duplicated. The goal will be to have the devices to be so separated, so that key parts of the system are done individually for the different devices, but the parts the surrounds the shared resources, like the TX and RX channels, is done for all the devices together.
\todo{a bit clearer definition of the goals is needed}
\section{Changed code}

\textbf{Structure}\\
\textbf{Flow of the code}\\