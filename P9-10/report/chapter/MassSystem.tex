\chapter{Massive IoT system overview}
\label{ch:MassOver}
The focus of this chapter is to provide an overview over the concepts and design of the \gls{MDE}. From \autoref{ch:NB-IoT} it is known that \todo{Insert knowledge fact about massive.} and a known concept is known from the project \citep{thesis_report}.

%It has a high cost to test massiveness scenarios with a massive amount of hardware devices and will require a system to control them individually, especially if the desire is to test the impact of massiveness on the individual devices. A more optimal solution is instead of buying a massive amount of devices, to emulate them through software.

To test the scenario of massiveness can be done in two ways, with a massive amount of hardware devices that require a system to control them individually or to emulate multiple devices in software using a minimal amount of hardware. For this type of emulation the optimal solution is the latter, as the desired amount of devices numbers several thousands. 

The challenges with emulating a massive amount of devices, is that every single device is complex, as seen through \autoref{ch:NB-IoT}, and not easy to emulate, as all the aspects of the devices functionalities are also wanted in the emulator. So to emulate a massive amount of devices, takes a lot of CPU power to process the data for each individual device and having enough memory for then and the data they receive. Another challenge is that the signals have to be combined for the different devices and send to the eNB and the signal from the eNB have to be split up to all the devices and this have to be handled quickly as the system operate in real time.

As seen in \autoref{tab:protocol_decision} from \autoref{ch:Introduction} there is multiple version of emulators for a single NB-IoT device, but as the protocol still is in development, these emulators are also in the development stage and they only emulate a single device. But as a foundation for the project the SRS NB-IoT emulator will be used as a baseline, as designing the emulator from scratch is undesired and to time consuming. The SRS emulator is chosen, as it was accessible to get with the source code, as there have to be some restructure in the code, and it is based on the LTE emulator from SRS, which was the baseline for an earlier project \citep{thesis_report}, which are the predecessor for this project.


The SRS NB-IoT emulator is a bigger c++ code project structured up into classes. As the code was never intended to emulate multiple devices, several changes is needed, to emulate multiple devices.


%The concept to produce this type of emulator, with the focus on having as high a number of devices active, while they still keep all functionalities for the individual device, will be to split up the code up into common parts, which can be used for all devices, and individual parts, which are only used for the individual device. To make this split between parts, the baseline code will be investigated.

The key idea for the emulator, is to split between active and inactive devices. This is done to achieve as high a number of devices as possible. Each device needs to keep all functionalities of a device, however some functionalities should be common for all devices. These functionalities refers to the radio layer functionalities, as only one radio is used for all devices it makes sense to only handle the radio functionalities once and share the data later to each device. To do this the code should be split up into common parts, which can be used for all devices, and individual parts, which are only used for the individual device. To make this split between parts, the baseline code will be investigated.

To test the emulator, it needs to communicated with a BS. To not interfere with other users and cancel out any other factors that can interfere with the whole setup, it is chosen to work with a BS emulator and connect the two emulator through wires. For the emulation of the eNB the Amarisoft LTE 100 code will be used as it can handle 1000 \gls{UE}s \citep{Amarisoft_solutions} and is tested to synchronize with the software based NB-IoT devices that will be used. 

To convert the signals, that the emulators produce, from digital to analog and reverse is there use a USRP B210 for each emulator, as it have been tested to work with both emulators. A last thing that have been put into the whole setup is a 30 dB attenuator, as the wired do not have as much path loss as transmission through air would have had.
This gives the whole setup seen in \autoref{fig:MassSetup}. 





%For the emulation of the eNB the Amarisoft LTE 100 code will be used as it can handle 1000 \gls{UE}s \citep{Amarisoft_solutions} and is tested to synchronize with the software based NB-IoT devices that will be used. As it is a commercial BSE, it is not open source and therefore harder to add new features and change all parameters, but as the focus is the devices, the software will still be used. A longer list of parameters for the Amarisoft LTE 100 code can be found in \appref{app:Amarisoft}.

%For the \gls{MDE} the code from SRS which have been tested to work with the software eNB from Amarisoft is chosen. This is chosen primarily because access to the source code is available through Keysight Technologies. As the code is designed for a single device some change have to be implemented, which requires knowledge of the original code. 

%The code will produce the infrastructure of the \gls{MDE} combining and transmitting the signals produced to the \gls{eNB}. The eNB will be emulated on secondary PC, as this frees up the PC running the \gls{MDE}. The NB-IoT spectrum overlaps with the LTE or GSM spectrum, meaning the spectrum is licensed, therefore a wire is used to connect \gls{MDE} and eNB. As the path loss in the wire is quite low, compared to transmission through the air, a 30 dB attenuator is added in between to increase the dynamic spectrum of the \gls{MDE} and eNB. To convert from digital signals to RF signals, a USRP B210 is connected to each the two emulators as these \gls{SDR}s are comparable with both softwares. The setup of the emulators can be seen on \autoref{fig:MassSetup}.

\tikzsetnextfilename{MassSetup}
\begin{figure}[H]
\centering
\resizebox{0.9\textwidth}{!}{
\input{figures/Mass_setup.tex}}
\caption{Overview of the emulator setup}
\label{fig:MassSetup}
\end{figure}




%The emulation of the massiveness scenarios uses the Massive IoT and eNB (Amarisoft) components. It is possible to connect and external NB-IoT device be combining its signal with the signals from the other two components. But as the focus for this part of the emulator is to stress test the protocol this feature will not be used. The Orchestrator is not used either in this part, as it has not been prioritized to set the two system together and have the same control unit. Both components is started up from a config file. While the Amarisoft software already fits to the purpose as an eNB, the SRS software code need to be change to emulate multiple UE. To understand this changes, there will be looked into the original code

%\section{eNB emulator}
%For the emulation of the eNB the Amarisoft LTE 100 code will be used as it can handle 1000 \gls{UE} \todo{Insert ref to Amarisoft side} and is tested to synchronize with the software based NB-IoT devices that will be used. As it is a commercial BSE, it is not open source and therefore harder to add new features and change all parameters, but as the focus is the devices, the software will still be used. A longer list of parameters for the Amarisoft LTE 100 code can be found \todo{Insert appendix for this}

%\section{Massive device emulator}
%For the emulation of the massive amount of NB-IoT devices the code provide by SRS which have been tested to work with the software eNB from Amarisoft. As the code is design for a single device some change have to be implemented, which requires knowledge of the original code.



\section{Baseline emulator}
As stated before, is the baseline emulator from SRS stil in development. The structure of the code have been copied from the LTE version, where it follows the communication layer structure known from \autoref{ch:NB-IoT}. The code process only goes up to msg2, as SRS have not developed the functionalities to transmit msg3 correctly. This blocks the possibilities to make a full attach and transmit data and all other functionalities after completing an attach. But as a prove of concept, to showcase the possibility of emulating a massive amount of device, as this aspect is one of the new aspects that have to be taken into account when using NB-IoT.

%The code provide by SRS is still in development and is based on the code SRS developed to LTE, which was used in \citep{thesis_report}. The structure of the code is very similar and with that, some of the structure change and solutions can be copied over from the mentioned project.

%Unfortunately as the code is still in development, the msg3 transmission does not work, as it seems that it gets transmitted in a wrong time slot. \todo{Check up on if this is what we want to say} This block the possibility to get a complete attach request, so the project will only work up to the reception of msg2. The plans for the changes and solution for the parts including the full attach procedure and data transmission, can be found in \autoref{ch:Future}.

\subsection{Structure}
\label{sub:MassStruct}
To estimate the parts of the code that should be common for all devices  and which shall be kept individual, there is a need to understand the structure of the code and how it performs different part of the NB-IoT protocol. As stated before is that code is split up into multiple classes and it is structure much similar to the LTE version of the code and it follows the communication layer structure. Their is two part of the code which is the srsLTE, where all lower layer functionalities and the API to communicated with the USRP B210, and the srsUE, where the main classes and control of the system is placed. The structure of the srsUE part can be seen in \autoref{fig:MassClass}. 

%The code is written in C++, with a little C in some of the lower level files. The code is divided up into two sections srsLTE, which contains all the lower layer functions and the radio layer, and srsUE, which emulate a device with all the different communication layers that handles the protocol. The code contains an amount of classes for the different layers known from the OSI model, as seen in \autoref{fig:MassClass}, with the PHY layer being split up into even more classes. All these classes is underclasses for an overall class called ue, which therefore contains all the parts needed for running a device.The structure of the PHY layer can be seen in \autoref{fig:PhyClass}. As multiple tasks is needed to be handled at the same time in the different layers, threading is used in multiple classes (PHY, PHCH recv, PHCH workers, MAC, RRC, GW).

\tikzsetnextfilename{MassClass}
\begin{figure}[H]
\centering
\resizebox{0.5\textwidth}{!}{
\input{figures/MassClass.tex}}
\caption{Class overview of SRS emulation code}
\label{fig:MassClass}
\end{figure}

The structure designed like the communication model OSI, but do not follow the model fully, which can be seen in their functionallities seen below.

\begin{itemize}
\item [Radio] The radio controls and sets all the parameters for the transmission and receiving. It is the only class connected to the SDR API and sends the data to it for transmission and receives data from it too. 
\item [PHY] The PHY class handles the synchronization, the receiving and decoding of MIB and SIBs messages and decoding and encoding of transmission and received data.
\item [MAC] Keep track of TTI and give grants to PHY class to decode and encode of DL and UL. Control flow from the PHY class to the RLC class. Take over the RAP from the NPRACH class for msg2 and onward.
\item [RRC] Is the overall control class for the whole device. Here it control how far through the process the device is and if it got all the needed parameters, which is the reason for it being connected to all lower classes, besides the radio class.
\end{itemize}

Even if the class layout look like the OSI model but it does not follow it on point especially the lower layers (PHY and MAC). This comes from that many of the MAC layers task is moved to the PHY class and normally the PHY layer is made up of physical components and do the task, that the SDR performs. The RLC, PDCP, GW, NAS and USIM classes is not used much, as their functionality is for the process after the RAP or at least msg4 have been received. Therefore have they not been though much development in the SRS code.

Between these classes are there some interfaces, that handles the movement of data, grants, parameters and other information. These interfaces is build as a class for it self for each interface, with an overall interface for functionalities used multiple places. 

The PHY class contains many tasks and and contains more classes which handles these tasks. The structure and description of these classes can be seen below.

\begin{figure}[H]
\centering
\tikzsetnextfilename{PhyClass}
\resizebox{0.5\textwidth}{!}{
\input{figures/PhyClass.tex}}
\caption{Class overview of the PHY layer from the SRS emulation code}
\label{fig:PhyClass}
\end{figure}

\begin{itemize}
\item [PHCH recv] Controls the whole PHY class system. Keeps track on which state the system is in and activates the different underclasses in the PHY class.
\item [PHCH common] Contains most parameters for the PHY underclasses, here under the RNTI's and metrics for UL and DL, and communication up to the MAC class and sends transmission data to the radio class.
\item [PHCH workers] Handles all processing of data after decoding of MIB and SIBs messages, both encoding and decoding dependably on the grants granted by the MAC class. Their can be multiple workers for one device, but in these cases, their will only be used one.
\item [Thread pool] Contains and controls the array of PHCH workers.	
\item [NPRACH] Used to send msg1 in the RAP and keep track of the parameters set for this transmission, like preamble id.
\end{itemize}

There are multiple other classes in the srsUE part, but they are a bi-product of the copied structure from the LTE version and are not executed, as either the feature have not been added yet or that its functionallities are first meant to be executed after msg2.

With the knowledge of the structure of the baseline, the process of code will be look into now.


\subsection{Execution of the code}
To understand more the changes that need to be implemented, there is looked into the processes in the code. The code is build up into multiple section which runs at different times, which is shown in \autoref{fig:MassStep}. After the initialization, the steps is matching the steps needed for a device to connect to an eNB. The different threads will go to different state, depending on which step in the process the code have made it to.

\begin{figure}[H]
\centering
\tikzsetnextfilename{MassStep}
\resizebox{0.5\textwidth}{!}{
\input{figures/MassStep.tex}}
\caption{A simplification of the steps in the code process}
\label{fig:MassStep}
\end{figure}

\textbf{Initialization} \\
The initialization step starts up all the different classes and sets pointers to the different interfaces between them and read the config file, which includes a longer list of parameters, which can be found in \appref{app:SRSconfig}. The PHY have a number of underclasses, as shown in \autoref{fig:PhyClass} and which are initialized in the PHY thread, which close down afterwards. The main thread will wait on the PHY to finish initialize, before sending an attach request, through the NAS class. This process is shown in \autoref{fig:InitStep}.

\begin{figure}[H]
\centering
\tikzsetnextfilename{InitStep}
\resizebox{0.5\textwidth}{!}{
\input{figures/InitFlow.tex}}
\caption{The process for the initialization. The dashed line indicates a event trigger to another thread.}
\label{fig:InitStep}
\end{figure}


\textbf{Synchronization and MIB} \\
The synchronization is where the device tries to find the NPSS and NSSS in the right frequency. This is done in the PHCH recv class, which handles both the synchronization and MIB, which is also decode here. The PHCH recv main functionalities is triggered in the loop, which run in it threads. This functionalities is triggered dependably on which state the class is in, which is shown in \autoref{fig:RecvState}.

\begin{figure}[H]
\centering
\tikzsetnextfilename{RecvState}
\resizebox{0.5\textwidth}{!}{
\input{figures/RecvState.tex}}
\caption{State machine for PHCH recv. The whole process start in ilde.}
\label{fig:RecvState}
\end{figure}
\todo{Write triggers into diagram}

The PHCH recv is in idle, until it gets triggered by the attach request, which have gone from the NAS to the RRC to the PHY, which then call sync start, so the state becomes cell search.

In cell search, the PHCH recv starts up the radio class and begins to receive signals from it, where it looks for the NPSS and NSSS through all different frequencies, where it will chose the one with the highest peak, over a certain level. If it does not find a frequency, where there supposed to be a cell, it retries and are stuck in this loop. If it finds a cell, it will then try to locate the MIB from the information from NPSS and NSSS. If it is found, the change the state from cell search to cell select.

In cell select the MIB is received and decoded and send to the MAC. In the case that it is not received well and can not be decoded in the first try \todo{Insert part with soft combining}. If it gets decode it will jump to cell measure, if their is none rsrp measurements \todo{gls maybe} or directly jump to cell camp, where it will begin to look into the SIB messages.

In cell measure it will measure the rsrp to correct the receiving parameters and then change to the cell camp stage.

Cell camp is the PHCH recv stage, where all further process will be handle, which starts out with the locating the SIB messages.

From all stages can the process be triggered to go into idle state, if an error occurred or the system tries to reset. Here it will try to start up into cell search again unless if it is the close down trigger.

\textbf{PHCH recv cell camp state} \\
When the PHCH recv is in cell camp state, is it ready to activate the PHCH workers, but first it will receive data and see if it have to transmit msg1 through the NPRACH class. The process can be seen in \autoref{fig:Cellcamp}.

\begin{figure}[H]
\centering
\tikzsetnextfilename{CellCamp}
\resizebox{0.7\textwidth}{!}{
\input{figures/Cellcamp.tex}}
\caption{The process for the PHCH recv, when it is in cell camp state}
\label{fig:Cellcamp}
\end{figure}

At first it need to find a idle worker and as long as no worker is not in idle, it will be blocking the main thread for continue. After finding a worker and setting it to be working, it request data from the radio, which receives data from the API for the USRP. If the data is not collected in time or if code is out of sync with the API, it will return a out of sync. If this is returned, the PHCH recv will release the worker and send a signal to the RRC, that it is out of sync, which cause the state of the PHCH recv to jump back to idle. If the radio returns in sync, the data is received with some synchronization parameter, such as \gls{CFO}, which are measured while receiving the data.

In the case that the device have received both SIB1 and SIB2 at this point, a flag in MAC class is set indicating that the msg1 in the \gls{RAP} needs to be send. If it is set, the PHCH recv will call the function in the NPRACH class to prepare a msg1, where it also chose a preamble id. When it is done, the NPRACH class sends the msg1 data to the radio, which transmit it and close down the transmission afterwards. This is the only place in the code, where it is not the working which handles uplink transmission.

When the process reached this point, after either transmitted the msg1 or not, the workers thread is activated and it begins to handle the data there. Meanwhile goes the PHCH recv thread back to the start of the process, if it still in cell camp state. If there is more workers for the device, it can now begin to handle the next data, before the previous worker is done, else it will have to wait for the single worker to go into idle state.

\textbf{Downlink decoding} \\
The first part of the process in the PHCH workers thread, is decoding of the DL data, received in the PHCH recv class. The process can be seen in \autoref{fig:DLwork}.

\begin{figure}[H]
\centering
\tikzsetnextfilename{DLwork}
\resizebox{0.8\textwidth}{!}{
\input{figures/DLwork.tex}}
\caption{The process for the downlink decoding in PHCH worker.}
\label{fig:DLwork}
\end{figure}

Firstly does the worker ask the MAC if it has a DL grant from earlier. If not, it will assume that the receive data is from NPDCCH, where it first search for a new DL grant and if that is not in the data, it search for a new UL grant. After the search for new grants, will it continue with the UL.

If the MAC have a DL grant from earlier, it will try to decode the data, which is send through the NPDSCH. If this is successful, it will send the decoded data up to MAC to handle it. After sending the data to the MAC or error in the decoding, there is a check if there should be send a ACK/NACK back to the BS. If this flag is set, it will generate the ACK/NACK and a new UL grant. Following this will the UL process begin.

\textbf{Uplink encoding and transmission} \\
After the DL, does the









To have the emulator emulate multiple devices, some parts of the original device is needed to be duplicated. The goal of these changes will be to have a massive amount of individual devices emulated, without them effecting each other through their processing time and combining their signals and transmit it as one to the eNB.

\section{Changed code}
This section looks into where the changes have been made to the code and what impact it should have had onto process and usage of the emulator.

The concept mentioned in the start of this chapter, focus on making as many functionalities common for all devices, to minimize the work load, but still have the devices to be as split as possible, so they still can be seen as individual devices.

\textbf{Radio}\\
Through the previous part about the structure of the code, it is seen that the radio class is at the bottom of the class structure and is the bottleneck for the simple strategy of copy the whole structure for each device, as there should only be one connection to communicate with the API to the USRP B210. Therefore should there only be one radio class.

The next point is to secure that all communication to the radio class is controlled. As seen in the previous structure section and in \autoref{fig:PhyClass}, is the only classes communication with the radio class: PHCH recv (for synchronazation and decoding of MIB), NPRACH (to transmit msg1 in the RAP) and PHCH common (with the data from the PHCH worker).

For the tranmission part, which comes from both the NPRACH and PHCH common, is there a need of combining all the signal correctly, compared to time slots and frequencies, while still being in sync with eNB. This will be fixed with a buffer system, that will receive data from the two classes and hold on to it, until it shall be transmitted. A problem comes when data have to be combine, as it have to be transmitted simultaneously. As different devices have possibility for different power level, a power combiner is implemented, that takes this parameter into account.

For the receiving part, which is sent only to PHCH recv. Here there is also a need of a buffer, so that all devices can get the data, before the next data is received. 
With these two buffer system, will the problem with combining and distribute the data be fixed, while the layers above can be copied and have all functionalities still intact. But with this setup, the bottleneck in the system will quickly be the workload on the CPU kernels, which is why there will be looked into lower the amount of workload. As different functionalities is tied to different classes, it will be best to look at which classes can be made common.

\textbf{PHCH recv}\\
As the control class among the PHY underclasses, can PHCH recv be common instead of individual for the different devices. One of the pros of having it as a common class, is that the buffer for receiving data, mention in the previous section about radio, can be moved up here, where it is called from. Another pro is that the synchronization and the decoding of the MIB can be made common task, as these two steps in the process will not influence other devices compared to test the limits of the NB-IoT protocol. The PHCH recv will also keep all the devices synchronized by measuring the DL channel. The con will be that devices will not be able to get off sync individual, if that wanted to be tested.

The other underclasses in the PHY class all contains parts which should be keep individual, as they include some parameters meant for the individual device (NPRACH have preamble id and PHCH common have RNTI's). A discussing can be made if a large PHCH worker array should be made, where all devices gets workers from, but to make sure that all devices always will have a worker running for it self, it will also be copied. The higher layers classes will also be copied, as these all include the state the different devices are in and to keep them still as individual as possible. 

With all classes, besides radio and PHCH recv being copied for each device emulated, some changes have to be made in the initialization.

\textbf{PHCH recv}\\



\input{chapter/TestMass.tex}